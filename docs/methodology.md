# Methodology

## Методи обробки невідомих значень для категоріальних змінних

`education` - 4% пропущених даних, можна замінити модою, але можна залишити "unknown", оскільки освіта може бути
важливим фактором. Тому для цього атрибута створимо додатковий - `education_unknown`, що буде приймати значення 1, якщо
значення "unknown", або 0, якщо атрибут має інше значення. Оригінальне значення "unknown" замінимо модою.

`default` - близько 20% значень невідомо, можемо залишити unknown, оскільки заповнення може призвести до спотворення
моделі, що, своєю чергою, знизить її ефективність. Високий відсоток пропусків може свідчити про те, що зміна значень має
важливе значення і потребує ретельного підходу. У default "unknown" містить інформацію про клієнтів, і заміна його на
"no" або "yes" може сильно змінити результати моделі. Тому ця категорія залишається.

`housing` та `loan` – по 2.4% значень "unknown", що варто залишити, оскільки це може бути корисною інформацією.

`job` та `marital` - до 1% значення "unknown", потенційно можливо заповнити модою, адже пропусків достатньо мало, і це
не сильно вплине на модель.

Обрана стратегія:

Залишаємо в датафреймі "unknown" як окрему категорію для категоріальних змінних, за винятком `education`.

## Методи для кодування категоріальних колонок

Оскільки значення "unknown", що зустрічається в деяких категоріальних змінних, вирішено залишити як окрему категорію, то
вона буде врахована при кодуванні кожної з таких змінних (окрім education).

### education

Для кодування цієї змінної буде застосовано метод ***OrdinalEncoder***, адже ми модемо встановити порядок рівням освіти,
за виключенням категорії "unknown". Якщо включити "unknown" в порядок рівнів освіти - це буде не вірно, наприклад в
кодуванні у значенні 0 - буде означати, що "unknown" - це найнижчий рівень освіти. Тому замінивши "unknown" на значення
моди та встновиваши атрибуту `education_unknown` значення 1 - зможемо закодувати більш корректно таку змінну як
`education`.

Порядок обраний для `education` змінної:

- illiterate - 0: найнижчий рівень освіти, що ітерпритуємо як *неписемний*
- basic.4y - 1, інтерпритуємо як *початкова освіта 4 роки*
- basic.6y - 2, інтерпритуємо як *початкова освіта 6 років*
- basic.9y - 3, інтерпритуємо як *базова середня освіта*
- high.school - 4, інтерпритуємо як *середня освіта*
- professional.course - 5, інтерпритуємо як *професійні курси*
- university.degree - 6: найвищий рівень освіти, інтерпритуємо як *університетський диплом*

Отже, в такому випадку ми зберігаємо інформацію про "unknown" як окремий сигнал. Альтерантивним варіантом було б
використати *OneHotEncoder* без створення нової змінної `education_unknown`, але маємо виражений порядок у значеннях для
змінної, тому *OrdinalEncoder* виглядає більш коректним вибором. До того ж *OneHotEncoder* отрималиб більше новіих
змінних, по змінні на кожну категорію.

### job/marital/housing/loan/default/poutcome

Для кодування цих змінних буде застосовано метод ***OneHotEncoder***, адже в даному випадку ми не маємо можливості
встановити порядку для категорій.
Категорію "unknown" також будемо кодувати. Для того щоб позбутися мультиколінеарності видалимо 1 нову змінну, а саме ту,
що буде відображати закодовану категорію "unknown".

### contact

Дану змінну буде закодовано як бінарну, оскільки маємо лише дві категорії: cellular та telephone. Після кодування,
змінна `contact` буде приймати значення 1 у випадку cellular, та 0 у випадку is_cell_contact (кількість значень cellular
переважає).

### month та day_of_week

`month` та `day_of_week` - це часові дані, де є чітка послідовність. Оскілкьки ці змінні мають певний порядок, можна
закодувати їх числами. Це збереже зв’язок між місяцями/днями та їх порядком у часі.

## **Стратегія обробки викидів**

Провівши дослідницький аналіз даних, було виявлено, що ми маємо викиди у певних колонках.
Викиди можуть викривляти статистичні характеристики змінних, знижувати узагальнювальну здатність моделі та призводити до
нестабільних або менш інтерпретованих результатів.

Тому ми застосуємо комбінований підхід до обробки викидів, який включає:

- **Обрізку крайніх значень** за допомогою процентилів для зменшення впливу аномальних значень.
- **Видалення змінних** де інформація не доступна на момент прогнозування. (`duration`).
- **Логарифмічне перетворення** для згладжування розподілу змінних із сильною асиметрією (`campaign`).
- **Створення бінарних ознак** для кращої інтерпретації (`was_contacted_before` на основі `pdays`).

Такий підхід дозволить покращити якість моделей, зберігаючи при цьому інформаційну цінність вихідних даних.

### Деталі трансформацій, застосованих до кожної змінної

| Змінна          | Обробка                                                                     |
|-----------------|-----------------------------------------------------------------------------|
| `age`           | Обрізка на 99-му перцентилі (≤ 71 років)                                    |
| `duration`      | Видалена (корелює з цільовою; пост-фактум)                                  |
| `campaign`      | Обрізка (≤14), логарифмічне перетворення `log(1 + campaign)`                |
| `pdays`         | Створено `was_contacted_before` (1 – був контакт, 0 – ні), `pdays` видалено |
| `previous`      | Обрізка на 99-му перцентилі (≤2)                                            |
| `cons.conf.idx` | Обрізка по 1-му та 99-му перцентилях                                        |

## Обробка дисбалансу класів

В даних наявний суттєвий дисбаланс класів: позитивний клас y = yes складає близько 11% від усіх записів. Такий
дисбаланс негативно впливає на здатність моделі навчатися на рідкісних прикладах.

Враховуючи, що частина ознак у датасеті є категоріальними, для ресемплінгу було обрано метод SMOTENC, який дозволяє
генерувати синтетичні приклади з урахуванням категоріальних змінних.
Застосування SMOTENC є ефективною стратегією для задач з категоріальними ознаками та дисбалансом, і в нашому випадку
дозволило суттєво покращити здатність моделі розпізнавати клієнтів, які потенційно оформлять депозит.

## Генерація нових ознак (Feature Engineering)

Для покращення якості прогнозування були створені додаткові ознаки, що враховують співвідношення між контактами, часові
особливості та історію взаємодії з клієнтом.

| Назва ознаки               | Опис                                                                                  | Тип     |
|----------------------------|---------------------------------------------------------------------------------------|---------|
| `campaign_previous_ratio`  | Відношення кількості контактів у поточній кампанії до кількості попередніх контактів. | Числова |
| `campaign_to_total_ratio`  | Частка контактів поточної кампанії від загальної кількості контактів.                 | Числова |
| `second_half_year`         | Вказує, чи відбувся контакт у другій половині року (липень–грудень).                  | Бінарна |
| `weekday_call`             | Вказує, чи дзвінок відбувся у будній день (понеділок–п’ятниця).                       | Бінарна |
| `total_contacts`           | Загальна кількість контактів з клієнтом (поточна кампанія + попередні).               | Числова |
| `was_previously_contacted` | Вказує, чи був клієнт раніше контактований (тобто `previous > 0`).                    | Бінарна |

Ці ознаки дозволяють моделі врахувати як кількісну активність контактів, так і сезонність чи наявність історії
взаємодії,
що підвищує точність прогнозу.

## Обґрунтування вибору метрик для оцінки якості моделей

У даній задачі маємо суттєвий дисбаланс класів: близько 89% клієнтів не оформлюють депозит, тоді як лише ~11% —
позитивний клас ("yes"). Тому стандартна метрика точності (accuracy) не є інформативною — навіть модель,
яка передбачає "no" для всіх, матиме високу точність, але жодної практичної цінності.

Для якісної оцінки моделей було обрано кілька метрик. Основною метрикою для порівняння моделей між собою стала
**ROC-AUC**, оскільки вона найбільш коректно відображає здатність моделі розрізняти класи незалежно від вибраного
порогу.

### Основна метрика: ROC-AUC

**ROC-AUC (Area Under the ROC Curve)** — це метрика, яка показує, наскільки добре модель відрізняє позитивний клас ("
yes") від негативного ("no") на різних порогах прийняття рішення.

> ROC-AUC була використана як **ключовий критерій для вибору найкращої моделі**.

### Додаткові метрики: F1-score та матриця плутанини

Окрім основної метрики, для повнішого розуміння якості моделі розглядалися:

- **F1-score** — показник, який балансує точність (precision) та повноту (recall). Він особливо корисний, коли важливі
  обидва аспекти: не пропустити позитивні приклади і не видавати надто багато хибних спрацювань.
    - Високий F1-score свідчить про хорошу здатність моделі виявляти "yes"-клієнтів із мінімальною кількістю помилок.
      Тож для додаткової оцінки моделі, щоб сформувати більш об'єктивний висновок про якість моделі, було розглянуто
      значення і цієї метрики.

- **Матриця плутанини** — візуалізує кількість правильних та помилкових передбачень по кожному класу. Допомагає
  детальніше зрозуміти, де саме модель помиляється: чи пропускає позитивні випадки, чи плутає класи.

Вибір такого набору дозволяє оцінити як загальну здатність моделі розрізняти класи, так і ефективність її практичного
використання.
