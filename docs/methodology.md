#Methodology

[[TOC]]

## Методи обробки невідомих значень для категоріальних змінних

`education` - 4% пропущених даних, можна замінити модою, але можна залишити "unknown", оскільки освіта може бути
важливим фактором. Тому для цього атрибута створимо додатковий - `education_unknown`, що буде приймати значення 1, якщо
значення "unknown", або 0, якщо атрибут має інше значення. Оригінальне значення "unknown" замінимо модою.

`default` - близько 20% значень невідомо, можемо залишити unknown, оскільки заповнення може призвести до спотворення
моделі, що, своєю чергою, знизить її ефективність. Високий відсоток пропусків може свідчити про те, що зміна значень має
важливе значення і потребує ретельного підходу. У default "unknown" містить інформацію про клієнтів, і заміна його на
"no" або "yes" може сильно змінити результати моделі. Тому ця категорія залишається.

`housing` та `loan` – по 2.4% значень "unknown", що варто залишити, оскільки це може бути корисною інформацією.

`job` та `marital` - до 1% значення "unknown", потенційно можливо заповнити модою, адже пропусків достатньо мало, і це
не сильно вплине на модель.

Обрана стратегія:

Залишаємо в датафреймі "unknown" як окрему категорію для категоріальних змінних, за винятком `education`.

## Методи для кодування категоріальних колонок

Оскільки значення "unknown", що зустрічається в деяких категоріальних змінних, вирішено залишити як окрему категорію, то
вона буде врахована при кодуванні кожної з таких змінних (окрім education).

### education

Для кодування цієї змінної буде застосовано метод ***OrdinalEncoder***, адже ми модемо встановити порядок рівням освіти,
за виключенням категорії "unknown". Якщо включити "unknown" в порядок рівнів освіти - це буде не вірно, наприклад в
кодуванні у значенні 0 - буде означати, що "unknown" - це найнижчий рівень освіти. Тому замінивши "unknown" на значення
моди та встновиваши атрибуту `education_unknown` значення 1 - зможемо закодувати більш корректно таку змінну як
`education`.

Порядок обраний для `education` змінної:

- illiterate - 0: найнижчий рівень освіти, що ітерпритуємо як *неписемний*
- basic.4y - 1, інтерпритуємо як *початкова освіта 4 роки*
- basic.6y - 2, інтерпритуємо як *початкова освіта 6 років*
- basic.9y - 3, інтерпритуємо як *базова середня освіта*
- high.school - 4, інтерпритуємо як *середня освіта*
- professional.course - 5, інтерпритуємо як *професійні курси*
- university.degree - 6: найвищий рівень освіти, інтерпритуємо як *університетський диплом*

Отже, в такому випадку ми зберігаємо інформацію про "unknown" як окремий сигнал. Альтерантивним варіантом було б
використати *OneHotEncoder* без створення нової змінної `education_unknown`, але маємо виражений порядок у значеннях для
змінної, тому *OrdinalEncoder* виглядає більш коректним вибором. До того ж *OneHotEncoder* отрималиб більше новіих
змінних, по змінні на кожну категорію.

### job/marital/housing/loan/default/poutcome

Для кодування цих змінних буде застосовано метод ***OneHotEncoder***, адже в даному випадку ми не маємо можливості
встановити порядку для категорій.
Категорію "unknown" також будемо кодувати. Для того щоб позбутися мультиколінеарності видалимо 1 нову змінну, а саме ту,
що буде відображати закодовану категорію "unknown".

### contact

Дану змінну буде закодовано як бінарну, оскільки маємо лише дві категорії: cellular та telephone. Після кодування,
змінна `contact` буде приймати значення 1 у випадку cellular, та 0 у випадку is_cell_contact (кількість значень cellular
переважає).

### month та day_of_week

`month` та `day_of_week` - це часові дані, де є чітка послідовність. Оскілкьки ці змінні мають певний порядок, можна
закодувати їх числами. Це збереже зв’язок між місяцями/днями та їх порядком у часі.

## **Стратегія обробки викидів**

Провівши дослідницький аналіз даних, було виявлено, що ми маємо викиди у певних колонках.
Викиди можуть викривляти статистичні характеристики змінних, знижувати узагальнювальну здатність моделі та призводити до
нестабільних або менш інтерпретованих результатів.

Тому ми застосуємо комбінований підхід до обробки викидів, який включає:

- **Обрізку крайніх значень** за допомогою процентилів для зменшення впливу аномальних значень.
- **Видалення змінних** де інформація не доступна на момент прогнозування. (`duration`).
- **Логарифмічне перетворення** для згладжування розподілу змінних із сильною асиметрією (`campaign`).
- **Створення бінарних ознак** для кращої інтерпретації (`was_contacted_before` на основі `pdays`).

Такий підхід дозволить покращити якість моделей, зберігаючи при цьому інформаційну цінність вихідних даних.

### Деталі трансформацій, застосованих до кожної змінної

#### `age`

- Значення > 99-го перцентиля (71 рік) обрізано.
- Мета — зменшити вплив вікових викидів із низькою репрезентативністю.

#### `duration`

- Видалено, оскільки змінна недоступна на момент прогнозу і прямо пов’язана з таргетом (data leakage).

#### `campaign`

- Обрізано на рівні 99-го перцентиля (14 контактів).
- Додатково застосовано логарифмічне перетворення: `log(1 + campaign)`.

#### `pdays`

- Створено нову ознаку `was_contacted_before` (`1`, якщо `pdays < 999`; `0`, якщо `pdays == 999`).
- Початкову змінну `pdays` видалено.

#### `previous`

- Обрізано значення > 2 (99-й перцентиль).

#### `cons.conf.idx`

- Обрізано крайні значення за 1-м і 99-м перцентилями.

#### Обробка дисбалансу класів

В даних наявний суттєвий дисбаланс класів: позитивний клас y = yes складає близько 11% від усіх записів. Такий
дисбаланс негативно впливає на здатність моделі навчатися на рідкісних прикладах.

Враховуючи, що частина ознак у датасеті є категоріальними, для ресемплінгу було обрано метод SMOTENC, який дозволяє
генерувати синтетичні приклади з урахуванням категоріальних змінних.
Застосування SMOTENC є ефективною стратегією для задач з категоріальними ознаками та дисбалансом, і в нашому випадку
дозволило суттєво покращити здатність моделі розпізнавати клієнтів, які потенційно оформлять депозит.

