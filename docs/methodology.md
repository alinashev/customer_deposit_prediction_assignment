## Description

### Методи обробки невідомих значень для категоріальних змінних

`education` - 4% пропущених даних, можна замінити модою, але можна залишити "unknown", оскільки освіта може бути
важливим фактором. Тому для цього атрибута створимо додатковий - `education_unknown`, що буде приймати значення 1, якщо
значення "unknown", або 0, якщо атрибут має інше значення. Оригінальне значення "unknown" замінимо модою.

`default` - близько 20% значень невідомо, можемо залишити unknown, оскільки заповнення може призвести до спотворення
моделі, що, своєю чергою, знизить її ефективність. Високий відсоток пропусків може свідчити про те, що зміна значень має
важливе значення і потребує ретельного підходу. У default "unknown" містить інформацію про клієнтів, і заміна його на 
"no" або "yes" може сильно змінити результати моделі. Тому ця категорія залишається.

`housing` та `loan` – по 2.4% значень "unknown", що варто залишити, оскільки це може бути корисною інформацією.

`job` та `marital` - до 1% значення "unknown", потенційно можливо заповнити модою, адже пропусків достатньо мало, і це
не сильно вплине на модель.

Обрана стратегія:

Залишаємо в датафреймі "unknown" як окрему категорію для категоріальних змінних, за винятком `education`.

### Методи для кодування категоріальних колонок

Оскільки значення "unknown", що зустрічається в деяких категоріальних змінних, вирішено залишити як окрему категорію, то
вона буде врахована при кодуванні кожної з таких змінних (окрім education).

#### education

Для кодування цієї змінної буде застосовано метод ***OrdinalEncoder***, адже ми модемо встановити порядок рівням освіти,
за виключенням категорії "unknown". Якщо включити "unknown" в порядок рівнів освіти - це буде не вірно, наприклад в
кодуванні у значенні 0 - буде означати, що "unknown" - це найнижчий рівень освіти. Тому замінивши "unknown" на значення
моди та встновиваши атрибуту `education_unknown` значення 1 - зможемо закодувати більш корректно таку змінну як
`education`.

Порядок обраний для `education` змінної:

- illiterate - 0: найнижчий рівень освіти, що ітерпритуємо як *неписемний*
- basic.4y - 1, інтерпритуємо як *початкова освіта 4 роки*
- basic.6y - 2, інтерпритуємо як *початкова освіта 6 років*
- basic.9y - 3, інтерпритуємо як *базова середня освіта*
- high.school - 4, інтерпритуємо як *середня освіта*
- professional.course - 5, інтерпритуємо як *професійні курси*
- university.degree - 6: найвищий рівень освіти, інтерпритуємо як *університетський диплом*

Отже, в такому випадку ми зберігаємо інформацію про "unknown" як окремий сигнал. Альтерантивним варіантом було б
використати *OneHotEncoder* без створення нової змінної `education_unknown`, але маємо виражений порядок у значеннях для
змінної, тому *OrdinalEncoder* виглядає більш коректним вибором. До того ж *OneHotEncoder* отрималиб більше новіих
змінних, по змінні на кожну категорію.

#### job/marital/housing/loan/default/poutcome

Для кодування цих змінних буде застосовано метод ***OneHotEncoder***, адже в даному випадку ми не маємо можливості
встановити порядку для категорій.
Категорію "unknown" також будемо кодувати. Для того щоб позбутися мультиколінеарності видалимо 1 нову змінну, а саме ту,
що буде відображати закодовану категорію "unknown".

#### contact

Дану змінну буде закодовано як бінарну, оскільки маємо лише дві категорії: cellular та telephone. Після кодування,
змінна `contact` буде приймати значення 1 у випадку cellular, та 0 у випадку is_cell_contact (кількість значень cellular
переважає).

#### month та day_of_week

`month` та `day_of_week` - це часові дані, де є чітка послідовність. Оскілкьки ці змінні мають певний порядок, можна
закодувати їх числами. Це збереже зв’язок між місяцями/днями та їх порядком у часі.

### **Стратегія обробки викидів**

Провівши дослідницький аналіз даних, було виявлено, що ми маємо викиди у певних колонках.
Викиди можуть викривляти статистичні характеристики змінних, знижувати узагальнювальну здатність моделі та призводити до
нестабільних або менш інтерпретованих результатів.

Тому ми застосуємо комбінований підхід до обробки викидів, який включає:

- **Обрізку крайніх значень** за допомогою процентилів для зменшення впливу аномальних значень.
- **Видалення змінних** де інформація не доступна на момент прогнозування. (`duration`).
- **Логарифмічне перетворення** для згладжування розподілу змінних із сильною асиметрією (`campaign`).
- **Створення бінарних ознак** для кращої інтерпретації (`was_contacted_before` на основі `pdays`).

Такий підхід дозволить покращити якість моделей, зберігаючи при цьому інформаційну цінність вихідних даних.

---

#### Деталі трансформацій, застосованих до кожної змінної

1. `age` (Вік клієнта)

- Вік клієнтів у датасеті коливається від **17 до 98 років**.
- Маємо велику кількість клієнтів у вікові групі за 70.
- **99-й перцентиль** становить **71**, тобто лише 1% клієнтів старше цього віку.

Неезважаючи на те, що літні люди можуть брати участь у кампаніях, їхня кількість є низькою, що може впливати на
стабільність моделі.

**Обрана стратегія:**

- Обрізаємо значення віку вище 99-го перцентиля (`age ≤ 71`), щоб зменшити вплив аномальних значень.

2. `duration` (Тривалість останнього контакту в секундах)

- Діапазон значень: **0 – 4918 секунд**. **99-й перцентиль** = **1271 секунд**, що означає, що 99% клієнтів розмовляли
  менше цього часу.
- Довгі дзвінки можуть свідчити про успішний результат.

**Обрана стратегія:**

- Видаляємо `duration`, оскільки вона напряму корелює з результатом кампанії.

3. `campaign` (Кількість контактів у поточній кампанії)

- Діапазон значень: **1 – 56 контактів**.
- **99-й перцентиль** = **14**, що означає, що лише 1% клієнтів контактували понад 14 разів.
- Дуже часті контакти (15+) можуть бути аномальними з точки зору маркетингової стратегії.

**Обрана стратегія:**

1. **Обрізаємо значення** вище **99-го перцентиля** (`campaign ≤ 14`).
2. **Застосовуємо логарифмічне перетворення** (`log(1 + campaign)`) для згладжування.

4. `pdays` (Кількість днів з останнього контакту)

- **Більшість значень** дорівнює `999`, що означає, що клієнт **не контактувався раніше**.
- Інші значення розподілені в широкому діапазоні.

**Обрана стратегія:**

- Створюємо **нову бінарну ознаку** `was_contacted_before`:
    - `1`, якщо `pdays < 999` (був контакт у минулій кампанії).
    - `0`, якщо `pdays = 999` (не було контакту).
- **Видаляємо `pdays`**, оскільки він більше не несе корисної інформації.

5. `previous` (Кількість попередніх контактів)

- Діапазон значень: **0 – 7 контактів**.
- **99-й перцентиль** = **2**, тобто понад 2 попередніх контакти зустрічаються рідко.

**Обрана стратегія:**

- **Обрізаємо значення** вище **99-го перцентиля** (`previous ≤ 2`), щоб виключити рідкісні випадки.

6. `cons.conf.idx` (Індекс довіри споживачів)

- Значення варіюються від **-50.8 до -26.9**.
- **1-й перцентиль** = **-49.5**, **99-й перцентиль** = **-26.9**, отже, екстремальні значення можуть викривляти
  розподіл.

**Обрана стратегія:**

- **Обрізаємо значення** за **1-м та 99-м перцентилями**, щоб усунути крайні значення.

### Обробка дисбалансу класів

В даних наявний суттєвий дисбаланс класів: позитивний клас y = yes складає близько 11% від усіх записів. Такий
дисбаланс негативно впливає на здатність моделі навчатися на рідкісних прикладах.

Враховуючи, що частина ознак у датасеті є категоріальними, для ресемплінгу було обрано метод SMOTENC, який дозволяє
генерувати синтетичні приклади з урахуванням категоріальних змінних.
Застосування SMOTENC є ефективною стратегією для задач з категоріальними ознаками та дисбалансом, і в нашому випадку
дозволило суттєво покращити здатність моделі розпізнавати клієнтів, які потенційно оформлять депозит.

